#### Despite being named "test_varfield", these tests actually test the whole
#### process, end to end.

context('Field generation')

### Run the analysis and generation.  The results of these calculations will be
### tested in the test case below.

griddata <- read.ncdf(system.file('extdata/tann1.nc', package='fldgen'))
tgav <- readtgav(system.file('extdata/wgttann1.nc', package='fldgen'))
pscl <- pscl_analyze(griddata$tas, tgav)
reof <- eof_analyze(pscl$r, griddata$tgop)
Fx <- mvfft(reof$x)                     # Fourier transforms of the coordinates
                                        # of the basis functions
Fxmag <- abs(Fx)
Fxphase <- atan2(Im(Fx), Re(Fx))
tempgrids <- list()                     # Empty list to hold the temperature
                                        # realizations
length(tempgrids) <- 4

##  Run with the phases of the actual time series
meanfield <- pscl_apply(pscl, tgav)
tempgrids[[1]] <- reconst_fields(reof$rotation, mkcorrts(Fxmag, Fxphase) , meanfield)
## Run the rest with random phases
for(i in 2:4)
    ## If you wanted to use only 50 PCs, like in the previous demo, you could
    ## use reof$rotation[,1:50] and Fxmag[,1:50] in the next call.
    tempgrids[[i]] <- reconst_fields(reof$rotation, mkcorrts(Fxmag), meanfield)



test_that('Values produced by global mean calculation agree with the ones produced by CDO.',
{
    ## matrix multiply:  ntime x ngrid * ngrid x 1  = ntime x 1
    tg_ours <- griddata$tas %*% griddata$tgop
    tgdiff <- tg_ours - tgav

    ## CDO is a little more rigorous in its calculation (it doesn't use the
    ## small angle approximation for delta-latitude), so allow discrepancies of
    ## up to 1e-4 times the average magnitude.
    ftol <- 1.0e-4 * mean(abs(tgav))
    maxdiff <- max(abs(tgdiff))
    expect_lte(maxdiff, ftol)
})



test_that('Applying the pattern scaling and adding back the residuals recovers the original temperatures.',
{
    tscl <- pscl_apply(pscl, tgav) + pscl$r

    ## Allow for some roundoff error
    ftol <- 1.0e-6 * mean(abs(tgav))
    diff <- tscl - griddata$tas
    maxdiff <- max(abs(diff))

    expect_lte(maxdiff, ftol)
})


test_that('All EOFs are normalized and orthogonal to one another.',
{
    ## check that all eofs are normalized and orthogonal to one another.  We do
    ## this by multiplying the matrix of basis vectors by its transpose and
    ## comparing to the identity matrix.
    tprod <- t(reof$rotation) %*% reof$rotation
    maxdiff <- max(abs(tprod - diag(ncol(tprod))))
    expect_lte(maxdiff, 1.0e-8)
})

test_that('EOFs other than PC0 have zero global average.',
{
    ## check that eofs other than PC0 have zero global average.  (Technically
    ## this is guaranteed by the test above, but this test serves as independent
    ## confirmation.)
    maxtg <- max( t(griddata$tgop) %*% reof$rotation[,-1] )
    expect_lte(maxtg, 1.0e-8)
})


test_that('Residual field can be recovered from basis and rotated coordinates.',
{
    ## We will be a little lenient on this test because there is plenty of
    ## opportunity for roundoff errors to accumulate in this calculation.
    resid.reconst <- reconst_fields(reof$rotation, reof$x)
    diff <- resid.reconst - pscl$r
    maxdiff <- max(abs(diff))
    ftol <- 1.0e-4 * mean(abs(pscl$r))
    expect_lte(maxdiff, ftol)
})



## We will run this function with two different test data sets below.
validate_mkcorrts <- function(testts=NULL)
{
    ## if we weren't given any test time series, generate a pair of them
    if(is.null(testts)) {
        x <- 0:31
        testts <- matrix(c(sin(4*pi*x/32.0), sin(5*pi*x/32.0)), ncol=2)
    }
    Fx <- mvfft(testts)
    Fxmag <- abs(Fx)
    phase <- atan2(Im(Fx), Re(Fx))

    ## Running mkcorrts with these phases should reproduce the original time
    ## series
    testout1 <- mkcorrts(Fxmag, phase, complexout=TRUE)
    ## Verify that there are no imaginary components
    expect_equal(testout1, Re(testout1)*1+0i)
    ## Verify equality with original inputs
    expect_equal(testts, Re(testout1))

    ## Running mkcorrts with random phases should produce statistically
    ## equivalent time series.  It's not obvious how to test this in a
    ## non-tautological way.  For now, we'll be satisfied with checking the mean
    ## and standard deviation.  Note that we have to look at the absolute value
    ## of the mean because we can't guarantee the phase of the DC component is
    ## the same as the input.
    testout2 <- mkcorrts(Fxmag)
    meansin <- abs(apply(testts, 2, mean))
    meansout <- abs(apply(testout2, 2, mean))
    expect_equal(meansin, meansout)
    sdin <- apply(testts, 2, sd)
    sdout <- apply(testout2, 2, sd)
    expect_equal(sdin, sdout)
}

test_that('Time series generated by mkcorrts have the correct properties.',
{
    validate_mkcorrts()
    validate_mkcorrts(reof$x)
})

### Run validation functions
#validate_global_mean(griddata)
#validate_pscl(pscl, griddata)
#validate_eof(reof, griddata, pscl)
#validate_mkcorrts(reof$x)

### We could add some output and/or visualization code here.
