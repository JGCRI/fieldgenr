#### Despite being named "test_varfield", these tests actually test the whole
#### process, end to end.

context('Field generation')

### Legacy T only

### Run the analysis and generation.  The results of these calculations will be
### tested in the test case below.

tann1 <- train(system.file('extdata/tann1.nc', package='fldgen'))

griddata <- tann1$griddata
tgav <- tann1$tgav
pscl <- tann1$pscl
reof <- tann1$reof

Fxmag <- tann1$fx$mag

## Get the phase and complex fft directly from reof$x.  These are only needed
## for tests, not production calculations
Fx <- mvfft(reof$x)
Fxphase <- atan2(Im(Fx), Re(Fx))

tempgrids <- list()                     # Empty list to hold the temperature
                                        # realizations
length(tempgrids) <- 4

##  Run with the phases of the actual time series
meanfield <- pscl_apply(pscl, tgav)
tempgrids[[1]] <- reconst_fields(reof$rotation, mkcorrts(tann1, Fxphase) , meanfield)
## Run the rest with random phases
for(i in 2:4)
    ## If you wanted to use only 50 PCs, like in the previous demo, you could
    ## use reof$rotation[,1:50] and Fxmag[,1:50] in the next call.
    tempgrids[[i]] <- reconst_fields(reof$rotation, mkcorrts(tann1), meanfield)



test_that('legacy T - Values produced by global mean calculation agree with the ones produced by CDO.',
{
    ## matrix multiply:  ntime x ngrid * ngrid x 1  = ntime x 1
    tg_ours <- griddata$tas %*% griddata$tgop
    tgdiff <- tg_ours - tgav

    ## CDO is a little more rigorous in its calculation (it doesn't use the
    ## small angle approximation for delta-latitude), so allow discrepancies of
    ## up to 1e-4 times the average magnitude.
    ftol <- 1.0e-4 * mean(abs(tgav))
    maxdiff <- max(abs(tgdiff))
    expect_lte(maxdiff, ftol)
})



test_that('legacy T - Applying the pattern scaling and adding back the residuals recovers the original temperatures.',
{
    tscl <- pscl_apply(pscl, tgav) + pscl$r

    ## Allow for some roundoff error
    ftol <- 1.0e-6 * mean(abs(tgav))
    diff <- tscl - griddata$tas
    maxdiff <- max(abs(diff))

    expect_lte(maxdiff, ftol)
})


test_that('legacy T - All EOFs are normalized and orthogonal to one another.',
{
    ## check that all eofs are normalized and orthogonal to one another.  We do
    ## this by multiplying the matrix of basis vectors by its transpose and
    ## comparing to the identity matrix.
    tprod <- t(reof$rotation) %*% reof$rotation
    maxdiff <- max(abs(tprod - diag(ncol(tprod))))
    expect_lte(maxdiff, 1.0e-8)
})

test_that('legacy T - EOFs other than PC0 have zero global average.',
{
    ## check that eofs other than PC0 have zero global average.  (Technically
    ## this is guaranteed by the test above, but this test serves as independent
    ## confirmation.)
    maxtg <- max( t(griddata$tgop) %*% reof$rotation[,-1] )
    expect_lte(maxtg, 1.0e-8)
})


test_that('legacy T - PSD returned from training matches manually calculated.',
{
    expect_equal(Fxmag, abs(Fx))
})


test_that('legacy T - Residual field can be recovered from basis and rotated coordinates.',
{
    ## We will be a little lenient on this test because there is plenty of
    ## opportunity for roundoff errors to accumulate in this calculation.
    resid.reconst <- reconst_fields(reof$rotation, reof$x)
    diff <- resid.reconst - pscl$r
    maxdiff <- max(abs(diff))
    ftol <- 1.0e-4 * mean(abs(pscl$r))
    expect_lte(maxdiff, ftol)
})



## We will run this function with two different test data sets below.
validate_mkcorrts <- function(testts=NULL, method=1)
{
    ## if we weren't given any test time series, generate a pair of them
    if(is.null(testts)) {
        x <- 0:31
        testts <- matrix(c(sin(4*pi*x/32.0), sin(5*pi*x/32.0)), ncol=2)
    }
    Fx <- mvfft(testts)
    Fxmag <- abs(Fx)
    Fxphase <- atan2(Im(Fx), Re(Fx))
    phcoef <- phase_eqn_coef(Fx)
    tsobj <- fldgen_object(NULL, NULL, NULL, NULL, Fxmag, phcoef, 'none')

    ## Running mkcorrts with these phases should reproduce the original time
    ## series
    testout1 <- mkcorrts(tsobj, Fxphase, complexout=TRUE)
    ## Verify that there are no imaginary components
    expect_equal(testout1, Re(testout1)*1+0i)
    ## Verify equality with original inputs
    expect_equal(testts, Re(testout1))

    ## Running mkcorrts with random phases should produce statistically
    ## equivalent time series.  It's not obvious how to test this in a
    ## non-tautological way.  For now, we'll be satisfied with checking the mean
    ## and standard deviation.  Note that we have to look at the absolute value
    ## of the mean because we can't guarantee the phase of the DC component is
    ## the same as the input.
    testout2 <- mkcorrts(tsobj)
    meansin <- abs(apply(testts, 2, mean))
    meansout <- abs(apply(testout2, 2, mean))
    expect_equal(meansin, meansout)
    sdin <- apply(testts, 2, sd)
    sdout <- apply(testout2, 2, sd)
    expect_equal(sdin, sdout)
}

test_that('legacy T - Time series generated by mkcorrts method 1 have the correct properties.',
{
    validate_mkcorrts()
    validate_mkcorrts(reof$x)
})

test_that('legacy T - Time series generated by mkcorrts method 2 have the correct properties.',
{
    validate_mkcorrts(method=2)
    validate_mkcorrts(reof$x, method=2)
})

test_that('legacy T - psdest produces equivalent results to manual calculation.',
{
    ## do analysis with psdest
    psd1 <- psdest(reof)
    ## repeat it manually
    Fx <- mvfft(reof$x)
    Fxmag <- abs(Fx)

    expect_equal(sqrt(psd1$psd), Fxmag)

    ## A list of two identical inputs should also give back the same result.
    psd2 <- psdest(list(reof, reof))
    expect_equal(sqrt(psd2$psd), Fxmag)
})


###############################
### Joint TP

### Run the analysis and generation.  The results of these calculations will be
### tested in the test case below.
emulator <- trainTP(c(system.file('extdata/tas_annual_esm_rcp_r2i1p1_startyr-endyr.nc', package='fldgen'),
                      system.file('extdata/pr_annual_esm_rcp_r2i1p1_startyr-endyr.nc', package='fldgen')),
                    tvarname = "tas", tlatvar = "lat_2", tlonvar = "lon_2",
                    pvarname = "pr", platvar = "lat", plonvar = "lon")

griddataT <- emulator$griddataT
griddataP <- emulator$griddataP
tgav <- emulator$tgav
meanfldT <- emulator$meanfldT
meanfldP <- emulator$meanfldP
reof <- emulator$reof

Fxmag <- emulator$fx$mag

## Get the phase and complex fft directly from reof$x.  These are only needed
## for tests, not production calculations
Fx <- mvfft(reof$x)
Fxphase <- atan2(Im(Fx), Re(Fx))



##  Run with the phases of the actual time series
## Note that every entry of newgrids is in the normal space and needs to be
## converted back to the native space
newgrids <- list() # Empty list to hold the temperature realizations
length(newgrids) <- 4
newgrids[[1]] <- reconst_fields(reof$rotation, mkcorrts(emulator, phase = Fxphase))

## Run the rest with random phases
for(i in 2:4)
    ## If you wanted to use only 50 PCs, like in the previous demo, you could
    ## use reof$rotation[,1:50] and Fxmag[,1:50] in the next call.
    newgrids[[i]] <- reconst_fields(reof$rotation, mkcorrts(emulator))

## Return these new grids of residuals to the native space
Ngrid <- 55296
residgrids <- lapply(newgrids, function(g) {
    g[, 1:Ngrid] <- unnormalize.resids(empiricalquant = emulator$tfuns$quant,
                                       rn = g[ ,1:Ngrid])$rnew

    g[, (Ngrid+1):(2*Ngrid)] <- unnormalize.resids(empiricalquant = emulator$pfuns$quant,
                                                   rn = g[ , (Ngrid+1):(2*Ngrid)])$rnew

    return(g)}
)

## use the new residuals in the native space with the mean field to reconstruct
## the full new fields
fullgrids <- lapply(residgrids, function(g){
    g[, 1:Ngrid] <- g[, 1:Ngrid] + pscl_apply(meanfldT, tgav)
    g[, (Ngrid+1):(2*Ngrid)] <- g[, (Ngrid+1):(2*Ngrid)] + pscl_apply(meanfldP, tgav)

    return(g)}
)

test_that('T Values produced by global mean calculation agree with the ones produced by CDO.',
          {
              ## matrix multiply:  ntime x ngrid * ngrid x 1  = ntime x 1
              tg_ours <- griddataT$vardata %*% griddataT$globalop
              tgdiff <- tg_ours - tgav

              ## CDO is a little more rigorous in its calculation (it doesn't use the
              ## small angle approximation for delta-latitude), so allow discrepancies of
              ## up to 1e-4 times the average magnitude.
              ftol <- 1.0e-4 * mean(abs(tgav))
              maxdiff <- max(abs(tgdiff))
              expect_lte(maxdiff, ftol)
          })



test_that('Applying the pattern scaling and adding back the residuals recovers the original temperatures.',
          {
              tscl <- pscl_apply(meanfldT, tgav) + meanfldT$r

              ## Allow for some roundoff error
              ftol <- 1.0e-6 * mean(abs(tgav))
              diff <- tscl - griddataT$vardata
              maxdiff <- max(abs(diff))

              expect_lte(maxdiff, ftol)
          })

test_that('Applying the pattern scaling and adding back the residuals recovers the original precipitations.',
          {
              prfield <- pscl_apply(meanfldP, tgav)
              prscl <- prfield + meanfldP$r

              ## Allow for some roundoff error
              ftol <- 1.0e-6 * max(abs(prfield))
              diff <- prscl - griddataP$vardata
              maxdiff <- max(abs(diff))

              expect_lte(maxdiff, ftol)
          })


test_that('All EOFs are normalized and orthogonal to one another.',
          {
              ## check that all eofs are normalized and orthogonal to one another.  We do
              ## this by multiplying the matrix of basis vectors by its transpose and
              ## comparing to the identity matrix.
              tprod <- t(reof$rotation) %*% reof$rotation
              maxdiff <- max(abs(tprod - diag(ncol(tprod))))
              expect_lte(maxdiff, 1.0e-8)
          })

test_that('EOFs other than PC0 have zero global average.',
          {
              ## check that eofs other than PC0 have zero global average.  (Technically
              ## this is guaranteed by the test above, but this test serves as independent
              ## confirmation.)
              maxtg <- max( t(rep(griddataT$globalop,2)) %*% reof$rotation[,-1] )
              expect_lte(maxtg, 1.0e-8)
          })


test_that('Time series generated by mkcorrts method 1 have the correct properties.',
          {
              validate_mkcorrts()
              validate_mkcorrts(reof$x)
          })

test_that('Time series generated by mkcorrts method 2 have the correct properties.',
          {
              validate_mkcorrts(method=2)
              validate_mkcorrts(reof$x, method=2)
          })

test_that('PSD returned from training matches manually calculated.',
          {
              expect_equal(Fxmag, abs(Fx))
          })


test_that('Residual field can be recovered from basis and rotated coordinates.',
          {
              ## The reconstructed residuals from reof will be in the normal space.
              ## Therefore, will compare to input residual field in the normal space.
              norm.input.resids <- cbind(
                  normalize.resids(inputresids = meanfldT$r,
                                   empiricalcdf = emulator$tfuns$cdf)$rn,
                  normalize.resids(inputresids = meanfldP$r,
                                   empiricalcdf = emulator$pfuns$cdf)$rn
                  )


              ## We will be a little lenient on this test because there is plenty of
              ## opportunity for roundoff errors to accumulate in this calculation.
              resid.reconst <- reconst_fields(reof$rotation, reof$x)
              diff <- resid.reconst - norm.input.resids
              maxdiff <- max(abs(diff))
              ftol <- 1.0e-6 * mean(abs(norm.input.resids))
              expect_lte(maxdiff, ftol)
          })



test_that('psdest produces equivalent results to manual calculation.',
          {
              ## do analysis with psdest
              psd1 <- psdest(reof)
              ## repeat it manually
              Fx <- mvfft(reof$x)
              Fxmag <- abs(Fx)

              expect_equal(sqrt(psd1$psd), Fxmag)

              ## A list of two identical inputs should also give back the same result.
              psd2 <- psdest(list(reof, reof))
              expect_equal(sqrt(psd2$psd), Fxmag)
          })
