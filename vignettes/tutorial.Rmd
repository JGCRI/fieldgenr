---
title: "Fldgen Tutorial"
author: "Robert Link"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  fig.width=8,
  comment = "#>"
)
```

The fldgen package allows you to ingest temperature output from an earth system
model (ESM) and generate randomized temperature fields that have the same space
and time correlation properties as the original ESM data.  This tutorial focuses
on how to use the functions in the package to generate and analyze temperature
fields.  The details of how the method works are covered in a companion paper. 
The statistics and analysis from that paper are used as the case study in this
tutorial.

All of the functions used here are documented in R's help system.  Since our
purpose here is to outline what functions have to be called, and in what
sequence, to perform the analysis, we haven't repeated material from the help
files.  If you're confused about how a function is supposed to work, consult the
help files.  For example, `help(read.ncdf)` will print the docs for the function
that reads the netCDF temperature fields.

## Using the field generator
### Reading the ESM data
```{r params}
## parameters for the code below.
ngen <- 4             # number of fields to generate
exfld <- 20           # example field to plot from the time series
```

All of the data needed for this tutorial is installed with the package.
```{r datadir}
library('fldgen')
datadir <- system.file('extdata', package='fldgen')
```

The ESM temperature field should be in a netCDF file.  The function that reads
it returns a "griddata" structure that contains the data, as well as some
information about the grid, such as the latitude, longitude, and time
coordinates and the vector of area weights needed to compute grid averages.

```{r readdata}
griddata <- read.ncdf(file.path(datadir, 'tann1.nc'))
tgav <- griddata$tas %*% griddata$tgop
```
Here, we have read in the netCDF data and used the global average operator to 
compute a time series of global mean temperatures.  These variables will be used
as input to the functions that analyze the ESM data and produce the temperature
fields.

### Generating fields

The first thing we need is a model for the mean temperature response in each
grid cell.  That is, for each grid cell, what is the mean temperature of that
cell as a function of global mean temperature.  You can use whatever model you
want for this.  We will use a simple linear pattern scaling model, which is
implemented in the `pscl_analyze` function.
```{r pscl}
pscl <- pscl_analyze(griddata$tas, tgav)
```

The mean response analysis should return the model coefficients (called `w` and
`b` in our linear model) and a time series of gridded residuals.  These
residuals encode all of the information about the spatial variability of the
ESM, so it is these we will pass to the empirical orthogonal functions (EOF)
analysis.  

```{r eof}
reof <- eof_analyze(pscl$r, griddata$tgop)
```

The last thing we need to generate our fields is the temporal structure of the
EOF coefficients.  We get this from the Fourier transform of the coordinates of
the residuals in the coordinate system defined by the EOF basis vectors.

```{r fft}
Fx <- mvfft(reof$x)
Fxmag <- abs(Fx)
Fxphase <- atan2(Im(Fx), Re(Fx))
```

Now we're ready to generate fields.  We'll do `r ngen` fields in this example. 
The first one will be a reconstruction of the original input.  The other three
will new fields.

```{r genfields}
tempgrids <- list()
length(tempgrids) <- ngen

## Here tgav is the same as the input, but that doesn't have to be the case
meanfield <- pscl_apply(pscl, tgav)

## First field will have the same phases as the input ESM data
tempgrids[[1]] <- reconst_fields(reof$rotation, mkcorrts(Fxmag, Fxphase), meanfield)

## Other fields will have random phases
for(i in 2:ngen) {
  tempgrids[[i]] <- reconst_fields(reof$rotation, mkcorrts(Fxmag), meanfield)
}
```

### Plotting the fields

We can extract a single field from each time series and plot them all for
comparision.  We will be able to see a lot more detail if we subtract out the
mean field from each one, so that's what we will do.

```{r plotfields, fig.show='hold'}
## Subtract off the mean field.  Save these because we will want to use them later
residgrids <- lapply(tempgrids, function(g) {
    g - meanfield
})

## Extract a single example field from each series and create a plot
fieldplots <- lapply(residgrids, function(g) {
    suppressWarnings(
        plot_field(g[exfld,], griddata, 13)
    )
})

## Display the plots
for (plt in fieldplots) {
    print(plt)
}
```
